================================================================================
           COLLECTIONS: DATA TYPE CONVERSIONS - IMPLEMENTATION GUIDE
                Master Type Conversions in JavaScript Like a Pro!
================================================================================

Welcome! This guide will teach you how to convert data between different 
JavaScript collection types‚ÄîArrays, Sets, Maps, Objects, and Strings. Think 
of this like learning to translate between different languages: the information 
stays the same, but the format changes!

If you've ever wondered how to transform a list of numbers into a unique set,
or how to turn an object into a map, this assignment is for you!

================================================================================
PART 1: UNDERSTANDING THE ASSIGNMENT
================================================================================

What You Need to Build:
------------------------
You'll create 12 conversion functions that transform data between different
JavaScript types:

‚Ä¢ arrToSet: Convert Array ‚Üí Set (removes duplicates automatically)
‚Ä¢ arrToStr: Convert Array ‚Üí String (joins all elements together)
‚Ä¢ setToArr: Convert Set ‚Üí Array (spreads set elements into array)
‚Ä¢ setToStr: Convert Set ‚Üí String (joins unique elements)
‚Ä¢ strToArr: Convert String ‚Üí Array (splits string into characters)
‚Ä¢ strToSet: Convert String ‚Üí Set (unique characters only)
‚Ä¢ mapToObj: Convert Map ‚Üí Object (uses key-value pairs)
‚Ä¢ objToArr: Convert Object ‚Üí Array (extracts values only)
‚Ä¢ objToMap: Convert Object ‚Üí Map (treats properties as key-value pairs)
‚Ä¢ arrToObj: Convert Array ‚Üí Array indices as keys, elements as values
‚Ä¢ strToObj: Convert String ‚Üí character indices as keys
‚Ä¢ superTypeOf: A function that returns the EXACT type of any value

Real-World Example:
-------------------
Imagine you're building a video game leaderboard:
  Input: [100, 250, 100, 500, 250] (player scores, some duplicates)
  
  Using arrToSet: Set { 100, 250, 500 } (unique scores only!)
  Using arrToStr: "10025010050" (string of all scores)
  Using arrToObj: { '0': 100, '1': 250, '2': 100, '3': 500, '4': 250 }

Why This Matters:
-----------------
Different data structures serve different purposes:
‚Ä¢ Arrays: Good for ordered data and iteration
‚Ä¢ Sets: Perfect for unique values (no duplicates)
‚Ä¢ Maps: Best for complex key-value relationships
‚Ä¢ Objects: Great for structured data with named properties
‚Ä¢ Strings: Used for text and simple concatenation

A professional programmer knows when to use each type and how to convert
between them. This skill will save you hours of debugging in your future
projects!

================================================================================
PART 2: KEY CONCEPTS YOU NEED TO UNDERSTAND
================================================================================

Concept 1: What are Collections?
---------------------------------
Collections are containers that hold multiple values. In JavaScript, the main
collections are:

**Array [ ]** - An ordered list that holds multiple values at different indices
Example: [1, 2, 3] - has values at positions 0, 1, 2

**Set new Set()** - A special collection that only stores UNIQUE values
Example: new Set([1, 2, 1, 3]) becomes Set { 1, 2, 3 } - the duplicate 1 is gone!

**Map new Map()** - Like an Object but more powerful. Stores key-value pairs.
Example: map.set('name', 'Alice') stores a connection between 'name' and 'Alice'

**Object { }** - Stores properties with key-value pairs (usually strings as keys)
Example: { x: 45, y: 75 } - properties 'x' and 'y' with their values

**String ' '** - Text data that can be accessed character by character
Example: 'hello' - each character is at a position: h(0), e(1), l(2), l(3), o(4)

ANALOGY: Think of a restaurant menu:
‚Ä¢ Array = A numbered list in order (item 1, item 2, item 3...)
‚Ä¢ Set = A list of UNIQUE items (no duplicate items listed twice)
‚Ä¢ Map = A detailed list with descriptions (item: [description])
‚Ä¢ Object = A categorized menu (appetizers: [...], mains: [...])
‚Ä¢ String = A single line of text you read left-to-right


Concept 2: The Spread Operator (...)
-------------------------------------
The spread operator (...) is like unpacking a suitcase and scattering everything
on the floor. It takes all elements from a collection and "spreads" them out.

Example:
const arr = [1, 2, 3]
const newArr = [...arr, 4, 5]  // newArr = [1, 2, 3, 4, 5]

For Sets and Arrays:
const set = new Set([1, 2, 3])
const arr = [...set]  // arr = [1, 2, 3]

The spread operator is ESSENTIAL for converting Sets to Arrays!


Concept 3: Object.entries() and Object.fromEntries()
------------------------------------------------------
These are powerful Object methods for conversions:

**Object.entries(obj)** - Breaks an object into [key, value] pairs
Example:
const obj = { name: 'Alice', age: 16 }
Object.entries(obj)  // [['name', 'Alice'], ['age', 16]]

**Object.fromEntries()** - Does the opposite! Builds an object from pairs
Example:
const entries = [['name', 'Alice'], ['age', 16]]
Object.fromEntries(entries)  // { name: 'Alice', age: 16 }

Why useful? Because Maps store data as [key, value] pairs, just like Object.entries!


Concept 4: typeof vs superTypeOf
---------------------------------
The built-in typeof operator has a limitation:

typeof [1, 2, 3]  // 'object' (not 'Array'!)
typeof new Map()  // 'object' (not 'Map'!)
typeof null       // 'object' (this is a famous JavaScript quirk!)

So we need to create superTypeOf() that returns the REAL type!

How? We use Object.prototype.toString.call(value) which tells us the true type.
Then we extract just the type name we want to return.


Concept 5: String/Array Similarity
----------------------------------
Strings and Arrays are surprisingly similar:

const str = 'hello'
const arr = ['h', 'e', 'l', 'l', 'o']

They both have:
‚úì A length property
‚úì Individual characters/elements at indices (0, 1, 2...)
‚úì Can be iterated with for...of loops

So converting between them is simple:
str.split('') ‚Üí ['h', 'e', 'l', 'l', 'o']
arr.join('')  ‚Üí 'hello'

================================================================================
PART 3: STEP-BY-STEP ALGORITHM (Your Thinking Process)
================================================================================

For ARRAY ‚Üí SET:
Step 1: Create a new empty Set
Step 2: Pass the array to the Set constructor
Step 3: The Set automatically removes duplicate values
Step 4: Return the Set

For ARRAY ‚Üí STRING:
Step 1: Use the join() method on the array
Step 2: Join with an empty string '' so nothing separates items
Step 3: Return the resulting string

For SET ‚Üí ARRAY:
Step 1: Spread the Set using [...set] or Array.from(set)
Step 2: Return the new array

For SET ‚Üí STRING:
Step 1: Convert Set to Array first using spread: [...set]
Step 2: Join the array elements: .join('')
Step 3: Return the string

For STRING ‚Üí ARRAY:
Step 1: Use split('') to break string into characters
Step 2: Return the array

For STRING ‚Üí SET:
Step 1: Convert string to array first: str.split('')
Step 2: Create Set from array: new Set(arr)
Step 3: Return the Set

For MAP ‚Üí OBJECT:
Step 1: Get all [key, value] pairs from the Map: [...map]
Step 2: Use Object.fromEntries() to build an object
Step 3: Return the object

For OBJECT ‚Üí ARRAY:
Step 1: Get the object's values: Object.values(obj)
Step 2: Return the array of values

For OBJECT ‚Üí MAP:
Step 1: Get entries from object: Object.entries(obj)
Step 2: Create a Map from entries: new Map(entries)
Step 3: Return the Map

For ARRAY ‚Üí OBJECT:
Step 1: Create empty object: {}
Step 2: Iterate through array with index
Step 3: Set each index as a key, element as value
Step 4: Return the object
OR use: Object.fromEntries(arr.map((el, i) => [i, el]))

For STRING ‚Üí OBJECT:
Step 1: Convert string to array first
Step 2: Convert array to object (same as above)
Step 3: Return the object

For superTypeOf:
Step 1: Use Object.prototype.toString.call(value)
Step 2: This returns a string like "[object Map]"
Step 3: Extract just the type name
Step 4: Return it (handle special cases: null, undefined)

================================================================================
PART 4: THE COMPLETE SOLUTION WITH COMMENTS
================================================================================

// Function 1: Convert Array to Set
// Sets automatically remove duplicates!
function arrToSet(arr) {
  return new Set(arr);
}

// Function 2: Convert Array to String
// Join all elements with empty string (no separator)
function arrToStr(arr) {
  return arr.join('');
}

// Function 3: Convert Set to Array
// Spread syntax (...) unpacks the Set into array elements
function setToArr(set) {
  return [...set];
}

// Function 4: Convert Set to String
// First convert Set to Array, then join elements
function setToStr(set) {
  return [...set].join('');
}

// Function 5: Convert String to Array
// Split breaks string into individual characters
function strToArr(str) {
  return str.split('');
}

// Function 6: Convert String to Set
// Convert to array first, then create Set (removes duplicate chars)
function strToSet(str) {
  return new Set(str.split(''));
}

// Function 7: Convert Map to Object
// Maps store [key, value] pairs, same as Object.entries format
function mapToObj(map) {
  return Object.fromEntries([...map]);
}

// Function 8: Convert Object to Array
// Extract just the values from the object (ignore keys)
function objToArr(obj) {
  return Object.values(obj);
}

// Function 9: Convert Object to Map
// Object.entries gives us [key, value] pairs - perfect for Map!
function objToMap(obj) {
  return new Map(Object.entries(obj));
}

// Function 10: Convert Array to Object
// Create object where index becomes key, element becomes value
function arrToObj(arr) {
  const obj = {};
  for (let i = 0; i < arr.length; i++) {
    obj[i] = arr[i];
  }
  return obj;
}

// Function 11: Convert String to Object
// Convert to array first, then convert array to object
function strToObj(str) {
  return arrToObj(str.split(''));
}

// Function 12: Super Type Of - returns the EXACT type
// Unlike typeof, this works for Arrays, Maps, Sets, etc.
function superTypeOf(value) {
  // Special cases that need explicit handling
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  
  // For everything else, use Object.prototype.toString
  // This returns a string like "[object Map]" or "[object Array]"
  const typeString = Object.prototype.toString.call(value);
  
  // Extract just the type name between "object " and "]"
  // Example: "[object Map]" ‚Üí "Map"
  return typeString.slice(8, -1);
}

Example Usage:
--------------

const str = 'hello';
const arr = [1, 2, 1, 3];
const obj = { x: 45, y: 75, radius: 24 };
const set = new Set([1, 2, 1, 3]);
const map = new Map([['a', 1], ['b', 2], [3, 'c'], [4, 'd']]);

console.log(arrToSet(arr));      // Set { 1, 2, 3 }
console.log(arrToStr(arr));      // '1213'
console.log(setToArr(set));      // [1, 2, 3]
console.log(setToStr(set));      // '123'
console.log(strToArr(str));      // ['h', 'e', 'l', 'l', 'o']
console.log(strToSet(str));      // Set { 'h', 'e', 'l', 'o' }
console.log(mapToObj(map));      // { a: 1, b: 2, '3': 'c', '4': 'd' }
console.log(objToArr(obj));      // [45, 75, 24]
console.log(objToMap(obj));      // Map { 'x' => 45, 'y' => 75, 'radius' => 24 }
console.log(arrToObj(arr));      // { '0': 1, '1': 2, '2': 1, '3': 3 }
console.log(strToObj(str));      // { '0': 'h', '1': 'e', '2': 'l', '3': 'l', '4': 'o' }

console.log(superTypeOf(map));        // 'Map'
console.log(superTypeOf(set));        // 'Set'
console.log(superTypeOf(obj));        // 'Object'
console.log(superTypeOf(str));        // 'String'
console.log(superTypeOf(666));        // 'Number'
console.log(superTypeOf(NaN));        // 'Number'
console.log(superTypeOf(arr));        // 'Array'
console.log(superTypeOf(null));       // 'null'
console.log(superTypeOf(undefined));  // 'undefined'
console.log(superTypeOf(superTypeOf)); // 'Function'

Explaining the Outputs:
-----------------------

arrToSet([1, 2, 1, 3]) = Set { 1, 2, 3 }
  ‚Üí The duplicate 1 is gone! Sets keep only unique values.

arrToStr([1, 2, 1, 3]) = '1213'
  ‚Üí Every element becomes part of the string, in order, no separators.

strToSet('hello') = Set { 'h', 'e', 'l', 'o' }
  ‚Üí Only 4 unique characters! The second 'l' is removed by the Set.

mapToObj(map) = { a: 1, b: 2, '3': 'c', '4': 'd' }
  ‚Üí Keys become property names, values become property values.
  ‚Üí Note: Numbers become strings as object keys!

superTypeOf(NaN) = 'Number'
  ‚Üí This is a famous JavaScript quirk: NaN is a NUMBER, not a string!
  ‚Üí typeof NaN returns 'number' (confusing but true)

================================================================================
PART 5: UNDERSTANDING THE LOGIC DEEPER
================================================================================

Let's trace through some examples step-by-step:

EXAMPLE 1: Converting [1, 2, 1, 3] to a Set
--------------------------------------------
Input: [1, 2, 1, 3]

Step by step:
1. new Set() creates an empty Set
2. Pass the array to Set constructor
3. Set iterates: adds 1 ‚Üí Set { 1 }
4. Set iterates: adds 2 ‚Üí Set { 1, 2 }
5. Set iterates: adds 1 ‚Üí Already exists! Skip (no change)
6. Set iterates: adds 3 ‚Üí Set { 1, 2, 3 }
7. Return: Set { 1, 2, 3 }

Key insight: Sets AUTOMATICALLY prevent duplicates!

EXAMPLE 2: Converting 'hello' to a Set
---------------------------------------
Input: 'hello'

Step by step:
1. str.split('') breaks string into characters: ['h', 'e', 'l', 'l', 'o']
2. new Set() on this array
3. Set adds 'h' ‚Üí Set { 'h' }
4. Set adds 'e' ‚Üí Set { 'h', 'e' }
5. Set adds 'l' ‚Üí Set { 'h', 'e', 'l' }
6. Set adds 'l' ‚Üí Already exists! Skip
7. Set adds 'o' ‚Üí Set { 'h', 'e', 'l', 'o' }
8. Return: Set { 'h', 'e', 'l', 'o' }

Key insight: The second 'l' disappears!

EXAMPLE 3: Understanding Object.prototype.toString.call()
----------------------------------------------------------
Why do we use this strange syntax for superTypeOf?

The trick: Different types have different internal [[Class]] values:

superTypeOf([1,2,3]):
  Object.prototype.toString.call([1,2,3])
  ‚Üí "[object Array]"
  ‚Üí Slice from position 8 to -1: "Array" ‚úì

superTypeOf(new Map()):
  Object.prototype.toString.call(new Map())
  ‚Üí "[object Map]"
  ‚Üí Slice from position 8 to -1: "Map" ‚úì

superTypeOf(null):
  typeof null ‚Üí 'object' (WRONG!)
  But we handle null specially: check if value === null first
  ‚Üí Return 'null' directly ‚úì

Why slice(8, -1)?
"[object Array]"
 0-7   8-12   13
 [object = 8 characters
 Array] = last character is index -1
 So we want indices 8 through -1 (not including -1)

EXAMPLE 4: Converting Array to Object
--------------------------------------
Input: [1, 2, 1, 3]

Step by step:
1. Create empty object: obj = {}
2. Loop i=0: obj[0] = 1 ‚Üí obj = { '0': 1 }
3. Loop i=1: obj[1] = 2 ‚Üí obj = { '0': 1, '1': 2 }
4. Loop i=2: obj[2] = 1 ‚Üí obj = { '0': 1, '1': 2, '2': 1 }
5. Loop i=3: obj[3] = 3 ‚Üí obj = { '0': 1, '1': 2, '2': 1, '3': 3 }
6. Return the object

Key insight: Object keys are ALWAYS strings! So 0 becomes '0'.

Why Arrays vs Objects Matter:
-----------------------------
Array: Optimized for indexed access and iteration
  const arr = [10, 20, 30]
  arr[0] = 10  ‚Üê Fast because it's designed for this
  arr.map(x => x * 2)  ‚Üê Easy iteration with methods

Object: Optimized for named properties
  const obj = { name: 'Alice', score: 100 }
  obj.name = 'Alice'  ‚Üê More readable than obj['0']
  Can't use array methods like .map() directly

Set: Optimized for uniqueness and membership testing
  const set = new Set([1, 2, 3])
  set.has(2)  ‚Üê Very fast! Is 2 in the set?
  Keeps data unique automatically

Map: Optimized for key-value relationships with any key type
  const map = new Map()
  map.set('user-1', { name: 'Alice' })
  map.set(42, 'special')  ‚Üê Can use any type as key (not just strings!)

================================================================================
PART 6: KEYWORDS & CONCEPTS TO EXPLORE FURTHER
================================================================================

Want to understand these topics better? Search for:

1. **Set** - A collection that only holds UNIQUE values
   Learn about: 
   - How Sets automatically remove duplicates
   - Set methods: .add(), .has(), .delete(), .clear()
   - When to use Set vs Array
   - Set performance advantages

2. **Map** - An advanced key-value collection (like Object but more powerful)
   Learn about:
   - How Maps allow any data type as keys (not just strings)
   - Map methods: .set(), .get(), .has(), .entries()
   - The difference between Map and Object
   - Real-world use cases for Maps

3. **Spread Syntax (...)** - The unpacking operator
   Learn about:
   - Using spread with arrays: [...arr1, ...arr2]
   - Using spread with Sets and other iterables
   - How spread makes conversion easier
   - Rest parameters vs spread syntax

4. **Array Methods** - Essential tools for data transformation
   Learn about:
   - .split() and .join() for string/array conversion
   - .map(), .filter(), .reduce() for array transformation
   - .entries(), .keys(), .values() on objects
   - Method chaining for powerful transformations

5. **Object Methods** - For working with objects
   Learn about:
   - Object.keys() - get all property names
   - Object.values() - get all property values
   - Object.entries() - get [key, value] pairs
   - Object.fromEntries() - build object from pairs

6. **typeof vs Object.prototype.toString** - Type detection
   Learn about:
   - Why typeof is limited
   - The quirks of typeof (typeof null === 'object')
   - How Object.prototype.toString.call() works
   - Creating your own type detection functions

Websites to explore:
- **MDN Web Docs** (developer.mozilla.org) - The most reliable JavaScript reference
- **JavaScript.info** (javascript.info) - Interactive lessons on advanced topics
- **FreeCodeCamp** (freecodecamp.org) - Video tutorials on data structures
- **w3schools.com** - Quick reference with interactive examples

================================================================================
PART 7: TESTING YOUR CODE IN A BROWSER
================================================================================

Method 1: Using the Browser Console (Easiest)
----------------------------------------------
This is the fastest way to test! Follow these steps:

1. Open any website in your browser
2. Press F12 (or Ctrl+Shift+I on Windows/Linux, Cmd+Option+I on Mac)
3. Click the "Console" tab
4. Copy-paste your functions, one at a time, and press Enter
5. Test each function with examples

Example in console:
  function arrToSet(arr) { return new Set(arr); }
  arrToSet([1, 2, 1, 3])
  // Set { 1, 2, 3 }

Quick tip: Use console.log() to print results:
  console.log(arrToSet([1, 2, 1, 3]));

Test Cases to Try:
   
   Test 1 - arrToSet:
   Input: [1, 2, 1, 3]
   Expected: Set { 1, 2, 3 }
   
   Test 2 - arrToStr:
   Input: [1, 2, 1, 3]
   Expected: '1213'
   
   Test 3 - strToSet:
   Input: 'hello'
   Expected: Set { 'h', 'e', 'l', 'o' }
   
   Test 4 - superTypeOf:
   Input: [1, 2, 3]
   Expected: 'Array'
   
   Input: new Set()
   Expected: 'Set'
   
   Input: new Map()
   Expected: 'Map'
   
   Input: null
   Expected: 'null'
   
   Input: undefined
   Expected: 'undefined'
   
   Input: NaN
   Expected: 'Number'

Method 2: Create an HTML File (More Professional)
---------------------------------------------------
This creates a nice test page you can share!

Steps:
1. Create a new file named "test-collections.html"
2. Copy the HTML template below
3. Save it and open it in your browser
4. You'll see test results printed on the page
5. Open browser console (F12) to see detailed outputs

HTML Template:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collections Test Suite</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
        }
        .test-group {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-case {
            margin: 15px 0;
            padding: 10px;
            background: #f9f9f9;
            border-left: 4px solid #007bff;
        }
        .pass {
            border-left-color: #28a745;
            color: #155724;
        }
        .fail {
            border-left-color: #dc3545;
            color: #721c24;
        }
        code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .input { font-weight: bold; }
        .output { color: #007bff; }
    </style>
</head>
<body>
    <h1>‚úì Collections Type Conversion Tests</h1>
    <div id="results"></div>

    <script>
        // PASTE ALL YOUR FUNCTIONS HERE
        function arrToSet(arr) {
            return new Set(arr);
        }

        function arrToStr(arr) {
            return arr.join('');
        }

        function setToArr(set) {
            return [...set];
        }

        function setToStr(set) {
            return [...set].join('');
        }

        function strToArr(str) {
            return str.split('');
        }

        function strToSet(str) {
            return new Set(str.split(''));
        }

        function mapToObj(map) {
            return Object.fromEntries([...map]);
        }

        function objToArr(obj) {
            return Object.values(obj);
        }

        function objToMap(obj) {
            return new Map(Object.entries(obj));
        }

        function arrToObj(arr) {
            const obj = {};
            for (let i = 0; i < arr.length; i++) {
                obj[i] = arr[i];
            }
            return obj;
        }

        function strToObj(str) {
            return arrToObj(str.split(''));
        }

        function superTypeOf(value) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            return Object.prototype.toString.call(value).slice(8, -1);
        }

        // Test Suite
        const results = document.getElementById('results');

        function testFunction(name, fn, input, expected) {
            try {
                const result = fn(input);
                
                // Special comparison for Sets
                if (expected instanceof Set && result instanceof Set) {
                    const match = [...result].every(v => expected.has(v)) && 
                                  [...expected].every(v => result.has(v));
                    return match;
                }
                
                // Special comparison for Maps
                if (expected instanceof Map && result instanceof Map) {
                    return JSON.stringify([...result]) === JSON.stringify([...expected]);
                }
                
                // For arrays and objects
                return JSON.stringify(result) === JSON.stringify(expected);
            } catch (e) {
                return false;
            }
        }

        function runTest(name, fn, input, expected) {
            const passed = testFunction(name, fn, input, expected);
            const status = passed ? '‚úì PASS' : '‚úó FAIL';
            const statusClass = passed ? 'pass' : 'fail';
            
            const testDiv = document.createElement('div');
            testDiv.className = `test-case ${statusClass}`;
            testDiv.innerHTML = `
                <strong>${status}: ${name}</strong><br>
                <span class="input">Input:</span> ${JSON.stringify(input).substring(0, 100)}<br>
                <span class="output">Expected:</span> ${String(expected).substring(0, 100)}
            `;
            results.appendChild(testDiv);
            
            console.log(`${status}: ${name}`);
        }

        // Run all tests
        results.innerHTML = '<div class="test-group"><h2>Array Conversions</h2></div>';

        // Array tests
        runTest('arrToSet([1, 2, 1, 3])', arrToSet, [1, 2, 1, 3], new Set([1, 2, 3]));
        runTest('arrToStr([1, 2, 1, 3])', arrToStr, [1, 2, 1, 3], '1213');
        runTest('arrToObj([1, 2, 1, 3])', arrToObj, [1, 2, 1, 3], { '0': 1, '1': 2, '2': 1, '3': 3 });

        results.innerHTML += '<div class="test-group"><h2>Set Conversions</h2></div>';

        // Set tests
        const set = new Set([1, 2, 1, 3]);
        runTest('setToArr(Set{1,2,3})', setToArr, set, [1, 2, 3]);
        runTest('setToStr(Set{1,2,3})', setToStr, set, '123');

        results.innerHTML += '<div class="test-group"><h2>String Conversions</h2></div>';

        // String tests
        runTest('strToArr("hello")', strToArr, 'hello', ['h', 'e', 'l', 'l', 'o']);
        runTest('strToSet("hello")', strToSet, 'hello', new Set(['h', 'e', 'l', 'o']));
        runTest('strToObj("hello")', strToObj, 'hello', { '0': 'h', '1': 'e', '2': 'l', '3': 'l', '4': 'o' });

        results.innerHTML += '<div class="test-group"><h2>Object Conversions</h2></div>';

        // Object tests
        const obj = { x: 45, y: 75, radius: 24 };
        runTest('objToArr({x:45,y:75,...})', objToArr, obj, [45, 75, 24]);
        runTest('objToMap({x:45,y:75,...})', objToMap, obj, new Map([['x', 45], ['y', 75], ['radius', 24]]));

        results.innerHTML += '<div class="test-group"><h2>Map Conversions</h2></div>';

        // Map test
        const map = new Map([['a', 1], ['b', 2], [3, 'c'], [4, 'd']]);
        runTest('mapToObj(map)', mapToObj, map, { a: 1, b: 2, '3': 'c', '4': 'd' });

        results.innerHTML += '<div class="test-group"><h2>SuperTypeOf Tests</h2></div>';

        // SuperTypeOf tests
        runTest('superTypeOf([1,2,3])', superTypeOf, [1, 2, 3], 'Array');
        runTest('superTypeOf({x:1})', superTypeOf, { x: 1 }, 'Object');
        runTest('superTypeOf("hello")', superTypeOf, 'hello', 'String');
        runTest('superTypeOf(123)', superTypeOf, 123, 'Number');
        runTest('superTypeOf(NaN)', superTypeOf, NaN, 'Number');
        runTest('superTypeOf(new Map())', superTypeOf, new Map(), 'Map');
        runTest('superTypeOf(new Set())', superTypeOf, new Set(), 'Set');
        runTest('superTypeOf(null)', superTypeOf, null, 'null');
        runTest('superTypeOf(undefined)', superTypeOf, undefined, 'undefined');
        runTest('superTypeOf(function(){})', superTypeOf, function(){}, 'Function');
    </script>
</body>
</html>

How to Use:
1. Open the HTML file in your browser
2. You'll see colored results (green = pass, red = fail)
3. Check the browser console (F12) for detailed logs
4. If any test fails, debug the function that failed

Method 3: Interactive Console Testing (Advanced)
-------------------------------------------------
For hands-on learning, test one function at a time in the browser console.

Try this workflow:
1. Define one function
2. Test it with several inputs
3. Use console.log() to see results
4. Check if the output matches what you expected
5. Move to the next function

Example console session:

// Step 1: Define function
function arrToSet(arr) {
  return new Set(arr);
}

// Step 2: Test it
arrToSet([1, 2, 1, 3])

// Step 3: Expected output
// Set { 1, 2, 3 }

// Step 4: Test with more cases
console.log(arrToSet([5, 5, 5, 1, 1, 9]));
// Set { 5, 1, 9 }

console.log(arrToSet(['a', 'a', 'b', 'c']));
// Set { 'a', 'b', 'c' }

This hands-on approach helps you truly understand what each function does!

================================================================================
PART 8: COMMON MISTAKES TO AVOID
================================================================================

‚ùå Mistake 1: Forgetting that Object keys are ALWAYS strings
   Problem: You create { 0: 'a', 1: 'b' } expecting numeric keys
   Solution: Remember that obj[0] is the same as obj['0']
   Example correct code: arrToObj converts index to string key

‚ùå Mistake 2: Using arr.toString() instead of arr.join('')
   Problem: [1, 2, 3].toString() = '1,2,3' (has commas!)
   Solution: Use arr.join('') to get '123' without separators
   Test: console.log([1, 2, 3].join('')); // '123'

‚ùå Mistake 3: Forgetting to spread Sets or Maps into Arrays
   Problem: Trying to use array methods on a Set
   Solution: Use [...set] to convert to array first
   Example: [...new Set([1,2,1])].map(x => x * 2)

‚ùå Mistake 4: Using typeof for advanced types
   Problem: typeof new Map() returns 'object' (not 'Map'!)
   Solution: Use Object.prototype.toString.call() for accurate types
   Example: Object.prototype.toString.call(new Map()).slice(8, -1) // 'Map'

‚ùå Mistake 5: Assuming Sets maintain order or have specific structure
   Problem: Expecting Set { 1, 2, 3 } to be printed nicely
   Solution: Remember Sets don't have indices; convert to array to access elements
   Example: const arr = [...set]; console.log(arr[0]); // First element

================================================================================
PART 9: BONUS CHALLENGES
================================================================================

Once you've finished the basic assignment, try these:

Challenge 1: Create a function that works with nested structures
   Description: Write arrToSet2D() that converts a 2D array to a Set of unique
   rows. Example: [[1,2], [1,2], [3,4]] ‚Üí Set of unique rows
   Hint: Convert rows to JSON strings for comparison

Challenge 2: Add validation and error handling
   Description: Modify functions to handle edge cases (null, empty, wrong types)
   Example: What should arrToSet(null) return? Throw error or return Set?
   Hint: Use try-catch blocks and input validation

Challenge 3: Create a function that converts anything to anything
   Description: Write a universal converter: convert(value, fromType, toType)
   Example: convert([1,2,3], 'array', 'set')
   Hint: Use a switch statement or object of functions

Challenge 4: Benchmark performance
   Description: Compare speed of different conversion methods
   Example: Which is faster - [...set] or Array.from(set)?
   Use console.time() and console.timeEnd()

Challenge 5: Create a deep clone function using your conversions
   Description: Write deepClone() that works with nested Maps, Sets, Arrays, Objects
   Example: deepClone({ a: new Set([1,2]), b: [1,2,3] })
   Hint: Recursively call deepClone on nested structures

================================================================================
PART 10: FINAL THOUGHTS
================================================================================

This assignment teaches several important programming concepts:

1. **Data Structure Basics** - Understanding different types of collections and
   when to use each one. Arrays for ordered data, Sets for unique values, Maps
   for complex relationships, Objects for structured data.

2. **Type Conversion** - How to transform data between different formats. This
   is crucial because different parts of your application might expect different
   data types.

3. **JavaScript's Quirks** - Learning why typeof doesn't always work (typeof null
   === 'object') and how to work around these strange behaviors.

4. **Object-Oriented Thinking** - Understanding how different data structures have
   different methods and properties. Sets have .add(), Maps have .set(), Arrays
   have .map().

5. **Advanced Type Inspection** - Mastering Object.prototype.toString.call() for
   reliable type detection, which is valuable for debugging and validation.

These skills are fundamental to all programming. Once you understand these concepts,
you can build much more complex applications! Real software engineers constantly
convert between different data types and structures.

Remember: Every professional programmer has struggled with these conversions at first.
The fact that you're learning them now puts you ahead of many beginners!

The goal isn't just to pass this assignment‚Äîit's to build intuition about how data
flows through your programs. When you truly understand collections, you can write
more efficient, cleaner code.

================================================================================
PART 11: COMPLETE CORRECT SOLUTION
================================================================================

Below is the final, clean version of the solution that you should submit:

```javascript
// Convert Array to Set (removes duplicates automatically)
function arrToSet(arr) {
  return new Set(arr);
}

// Convert Array to String (joins all elements, no separator)
function arrToStr(arr) {
  return arr.join('');
}

// Convert Set to Array (spreads set elements into new array)
function setToArr(set) {
  return [...set];
}

// Convert Set to String (convert to array, then join)
function setToStr(set) {
  return [...set].join('');
}

// Convert String to Array (split into individual characters)
function strToArr(str) {
  return str.split('');
}

// Convert String to Set (split to array, then to Set for unique chars)
function strToSet(str) {
  return new Set(str.split(''));
}

// Convert Map to Object (use spread to get entries, then fromEntries)
function mapToObj(map) {
  return Object.fromEntries([...map]);
}

// Convert Object to Array (extract values only, not keys)
function objToArr(obj) {
  return Object.values(obj);
}

// Convert Object to Map (use entries to get key-value pairs)
function objToMap(obj) {
  return new Map(Object.entries(obj));
}

// Convert Array to Object (use array indices as object keys)
function arrToObj(arr) {
  const obj = {};
  for (let i = 0; i < arr.length; i++) {
    obj[i] = arr[i];
  }
  return obj;
}

// Convert String to Object (convert to array first, then to object)
function strToObj(str) {
  return arrToObj(str.split(''));
}

// Return the EXACT type of any value (unlike typeof)
function superTypeOf(value) {
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  return Object.prototype.toString.call(value).slice(8, -1);
}
```

Verification of Correct Output:
--------------------------------

Test each function and verify these exact outputs:

const str = 'hello'
const arr = [1, 2, 1, 3]
const obj = { x: 45, y: 75, radius: 24 }
const set = new Set([1, 2, 1, 3])
const map = new Map([['a', 1], ['b', 2], [3, 'c'], [4, 'd']])

‚úì arrToSet(arr) equals Set { 1, 2, 3 }
‚úì arrToStr(arr) equals '1213'
‚úì setToArr(set) equals [1, 2, 3]
‚úì setToStr(set) equals '123'
‚úì strToArr(str) equals ['h', 'e', 'l', 'l', 'o']
‚úì strToSet(str) equals Set { 'h', 'e', 'l', 'o' }
‚úì mapToObj(map) equals { a: 1, b: 2, '3': 'c', '4': 'd' }
‚úì objToArr(obj) equals [45, 75, 24]
‚úì objToMap(obj) equals Map { 'x' => 45, 'y' => 75, 'radius' => 24 }
‚úì arrToObj(arr) equals { '0': 1, '1': 2, '2': 1, '3': 3 }
‚úì strToObj(str) equals { '0': 'h', '1': 'e', '2': 'l', '3': 'l', '4': 'o' }

‚úì superTypeOf(arr) equals 'Array'
‚úì superTypeOf(set) equals 'Set'
‚úì superTypeOf(map) equals 'Map'
‚úì superTypeOf(obj) equals 'Object'
‚úì superTypeOf(str) equals 'String'
‚úì superTypeOf(666) equals 'Number'
‚úì superTypeOf(NaN) equals 'Number'
‚úì superTypeOf(null) equals 'null'
‚úì superTypeOf(undefined) equals 'undefined'
‚úì superTypeOf(superTypeOf) equals 'Function'

If your function returns these exact values, you've solved it correctly!

Why This Solution Works:
------------------------
‚úì Uses built-in JavaScript methods (.split, .join, .entries, etc.)
‚úì Leverages Set's automatic uniqueness for duplicate removal
‚úì Properly converts between unordered (Set, Map) and ordered (Array) structures
‚úì Handles edge cases like null and undefined in superTypeOf
‚úì Is simple and efficient - no unnecessary loops or complexity
‚úì Follows JavaScript conventions and best practices
‚úì Each function does ONE job well (single responsibility principle)

================================================================================
PART 12: STEP-BY-STEP BROWSER TESTING GUIDE
================================================================================

QUICK START (Easiest Method - 2 minutes):
------------------------------------------

Step 1: Open your browser and go to any website (like Google)
Step 2: Press F12 to open Developer Tools (or Ctrl+Shift+I on Windows)
Step 3: Click the "Console" tab at the top
Step 4: Copy-paste the functions one at a time from Part 11
Step 5: Test each with the examples below

Complete Browser Console Test Script:
-------------------------------------
Copy ALL of this code at once and paste into your browser console:

```javascript
// Paste all 12 functions here (from Part 11)
function arrToSet(arr) { return new Set(arr); }
function arrToStr(arr) { return arr.join(''); }
function setToArr(set) { return [...set]; }
function setToStr(set) { return [...set].join(''); }
function strToArr(str) { return str.split(''); }
function strToSet(str) { return new Set(str.split('')); }
function mapToObj(map) { return Object.fromEntries([...map]); }
function objToArr(obj) { return Object.values(obj); }
function objToMap(obj) { return new Map(Object.entries(obj)); }
function arrToObj(arr) { const obj = {}; for (let i = 0; i < arr.length; i++) { obj[i] = arr[i]; } return obj; }
function strToObj(str) { return arrToObj(str.split('')); }
function superTypeOf(value) { if (value === null) return 'null'; if (value === undefined) return 'undefined'; return Object.prototype.toString.call(value).slice(8, -1); }

// Now test all functions
const str = 'hello';
const arr = [1, 2, 1, 3];
const obj = { x: 45, y: 75, radius: 24 };
const set = new Set([1, 2, 1, 3]);
const map = new Map([['a', 1], ['b', 2], [3, 'c'], [4, 'd']]);

console.log('=== ARRAY TESTS ===');
console.log('arrToSet([1, 2, 1, 3]):', arrToSet(arr));
console.log('Expected: Set { 1, 2, 3 }');
console.log('arrToStr([1, 2, 1, 3]):', arrToStr(arr));
console.log('Expected: "1213"');
console.log('arrToObj([1, 2, 1, 3]):', arrToObj(arr));
console.log('Expected: { 0: 1, 1: 2, 2: 1, 3: 3 }');

console.log('\n=== SET TESTS ===');
console.log('setToArr(Set{1,2,3}):', setToArr(set));
console.log('Expected: [ 1, 2, 3 ]');
console.log('setToStr(Set{1,2,3}):', setToStr(set));
console.log('Expected: "123"');

console.log('\n=== STRING TESTS ===');
console.log('strToArr("hello"):', strToArr(str));
console.log('Expected: [ "h", "e", "l", "l", "o" ]');
console.log('strToSet("hello"):', strToSet(str));
console.log('Expected: Set { "h", "e", "l", "o" }');
console.log('strToObj("hello"):', strToObj(str));
console.log('Expected: { 0: "h", 1: "e", 2: "l", 3: "l", 4: "o" }');

console.log('\n=== OBJECT TESTS ===');
console.log('objToArr({x:45,y:75,radius:24}):', objToArr(obj));
console.log('Expected: [ 45, 75, 24 ]');
console.log('objToMap({x:45,y:75,radius:24}):', objToMap(obj));
console.log('Expected: Map { "x" => 45, "y" => 75, "radius" => 24 }');

console.log('\n=== MAP TESTS ===');
console.log('mapToObj(map):', mapToObj(map));
console.log('Expected: { a: 1, b: 2, 3: "c", 4: "d" }');

console.log('\n=== SUPERTYPEOF TESTS ===');
console.log('superTypeOf([1,2,3]):', superTypeOf(arr));
console.log('superTypeOf({}):', superTypeOf(obj));
console.log('superTypeOf("hello"):', superTypeOf(str));
console.log('superTypeOf(123):', superTypeOf(123));
console.log('superTypeOf(NaN):', superTypeOf(NaN));
console.log('superTypeOf(new Map()):', superTypeOf(map));
console.log('superTypeOf(new Set()):', superTypeOf(set));
console.log('superTypeOf(null):', superTypeOf(null));
console.log('superTypeOf(undefined):', superTypeOf(undefined));
console.log('superTypeOf(function(){}):', superTypeOf(function(){}));
```

Expected Console Output:
------------------------
```
=== ARRAY TESTS ===
arrToSet([1, 2, 1, 3]): Set(3) { 1, 2, 3 }
Expected: Set { 1, 2, 3 }
arrToStr([1, 2, 1, 3]): 1213
Expected: "1213"
arrToObj([1, 2, 1, 3]): {0: 1, 1: 2, 2: 1, 3: 3}
Expected: { 0: 1, 1: 2, 2: 1, 3: 3 }

=== SET TESTS ===
setToArr(Set{1,2,3}): (3) [ 1, 2, 3 ]
Expected: [ 1, 2, 3 ]
setToStr(Set{1,2,3}): 123
Expected: "123"

=== STRING TESTS ===
strToArr("hello"): (5) [ 'h', 'e', 'l', 'l', 'o' ]
Expected: [ "h", "e", "l", "l", "o" ]
strToSet("hello"): Set(4) { 'h', 'e', 'l', 'o' }
Expected: Set { "h", "e", "l", "o" }
strToObj("hello"): {0: 'h', 1: 'e', 2: 'l', 3: 'l', 4: 'o'}
Expected: { 0: "h", 1: "e", 2: "l", 3: "l", 4: "o" }

=== OBJECT TESTS ===
objToArr({x:45,y:75,radius:24}): (3) [ 45, 75, 24 ]
Expected: [ 45, 75, 24 ]
objToMap({x:45,y:75,radius:24}): Map(3) { 'x' => 45, 'y' => 75, 'radius' => 24 }
Expected: Map { "x" => 45, "y" => 75, "radius" => 24 }

=== MAP TESTS ===
mapToObj(map): {a: 1, b: 2, 3: 'c', 4: 'd'}
Expected: { a: 1, b: 2, 3: "c", 4: "d" }

=== SUPERTYPEOF TESTS ===
superTypeOf([1,2,3]): Array
superTypeOf({}): Object
superTypeOf("hello"): String
superTypeOf(123): Number
superTypeOf(NaN): Number
superTypeOf(new Map()): Map
superTypeOf(new Set()): Set
superTypeOf(null): null
superTypeOf(undefined): undefined
superTypeOf(function(){}): Function
```

HTML File Method (More Professional):
--------------------------------------
See "Method 2" in Part 7 for the complete HTML test file. This creates a
beautiful test report in your browser!

Key steps:
1. Create file named "collections-test.html"
2. Copy the HTML code from Part 7
3. Save and open in browser
4. You'll see green checkmarks for passing tests

How to Use the HTML Test File:
1. Save the HTML from Part 7 to your computer
2. Open it with your browser (File ‚Üí Open)
3. Tests run automatically and display results
4. Red = failed test, Green = passed test
5. Check browser console (F12) for detailed output

Troubleshooting:
----------------
Problem: "Uncaught SyntaxError: Unexpected identifier"
Solution: Check your code for typos. Make sure all functions are correctly 
defined before testing. Look at the line number in the error message.

Problem: "TypeError: [function name] is not a function"
Solution: You haven't pasted/defined the function yet. Go back to Part 11 
and copy the function definition first, then test it.

Problem: Test output doesn't match expected output
Solution: 
  1. Check your function logic carefully
  2. Compare your output vs. expected output character-by-character
  3. Use console.log with simpler test cases to debug
  4. Re-read the concept explanations in Part 2 & 5

Problem: Set or Map not displaying correctly
Solution: Sets and Maps look different in console than in output. 
Use [...set] or [...map] to see their contents as arrays.

Example debugging:
  const mySet = new Set([1, 2, 1])
  console.log(mySet)          // Shows: Set { 1, 2 }
  console.log([...mySet])     // Shows: [ 1, 2 ] (easier to see!)

================================================================================

FINAL ENCOURAGEMENT:

You've just learned about one of the most important concepts in JavaScript:
data structure conversions. This skill will serve you well as you progress
in your programming journey.

Remember:
- Take your time understanding each concept
- Practice testing in the browser console
- Don't just memorize the code‚Äîunderstand WHY each line works
- Experiment with different test cases beyond what we provided
- Ask questions when something doesn't make sense

You're building real programmer skills. Be proud of that! Every expert
programmer started exactly where you are now. Keep coding, stay curious,
and never stop learning.

Happy coding! üöÄ

================================================================================
