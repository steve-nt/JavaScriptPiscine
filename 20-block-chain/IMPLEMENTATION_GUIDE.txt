================================================================================
                    BLOCKCHAIN - IMPLEMENTATION GUIDE
                 Build Your Own Digital Chain of Blocks!
================================================================================

Welcome! This guide will teach you how to build your very own blockchainâ€”a 
technology that powers Bitcoin and other cryptocurrencies. By the end, you'll 
understand how data is chained together securely using hashing, a fundamental 
concept in modern software development.

Imagine a chain of locked boxes where each box contains data and a unique 
fingerprint. If anyone tries to change what's inside an old box, its 
fingerprint changes, breaking the chain. That's blockchain in a nutshell!

================================================================================
PART 1: UNDERSTANDING THE ASSIGNMENT
================================================================================

What You Need to Build:
------------------------
â€¢ A function named `blockChain` that creates blocks in a chain
â€¢ Each block must contain: an index, a hash (fingerprint), data, and a 
  reference to the previous block
â€¢ Each block must have a `.chain()` method that creates the next block
â€¢ The hash must be calculated using a provided hashCode function with the 
  formula: index + previous_hash + stringified_data
â€¢ The first block (genesis block) should use { index: 0, hash: '0' } as its 
  previous block
â€¢ Each new block increments the index by 1

Real-World Example:
-------------------
INPUT:  blockChain({ a: 1 })
OUTPUT: A block object with:
        - index: 1
        - data: { a: 1 }
        - hash: '1103f27' (calculated from hashCode)
        - prev: { index: 0, hash: '0' } (genesis block)
        - chain: [a function that creates the next block]

When you call first.chain({ hello: 'world' }):
        - Creates a new block with index 2
        - Its hash depends on the index, previous hash, and new data
        - The previous block is now `first`

Why This Matters:
-----------------
Blockchain technology is used everywhere: cryptocurrency, supply chain 
tracking, medical records, and legal contracts. Understanding how blocks are 
chained together is the foundation for grasping how billions of dollars of 
cryptocurrency work! Companies like Microsoft and IBM are investing heavily in 
blockchain, making it a valuable skill for your future career in tech.

================================================================================
PART 2: KEY CONCEPTS YOU NEED TO UNDERSTAND
================================================================================

Concept 1: What is a Hash?
--------------------------
A hash is like a digital fingerprint. It's a unique string created from data 
using a mathematical function. Even a tiny change in the data creates a 
completely different hash.

Think of it like a unique ID number for a homework assignment: if you change 
even one word, the entire "fingerprint" changes. This is what makes blockchain 
secureâ€”you can't secretly modify old data because everyone would see that the 
hash changed!

Example:
  hashCode('10{"a":1}') â†’ '1103f27'
  hashCode('10{"a":2}') â†’ 'completely different hash'

Concept 2: JSON.stringify() - Converting Objects to Text
---------------------------------------------------------
JSON.stringify() takes a JavaScript object and converts it into a string 
representation. This is necessary because the hashCode function needs text 
(a string), not an object.

Example:
  const data = { a: 1 }
  JSON.stringify(data) â†’ '{"a":1}'
  
This is important because our hash calculation needs to combine the block's 
index, previous hash, and stringified data into one string.

Concept 3: Function Returns and Object Methods
-----------------------------------------------
In this assignment, your blockChain function returns an object. This object 
has properties (index, hash, data, prev) AND a method (chain) that is a 
function you can call.

Think of objects like real-world objects with properties and abilities:
  - A car object has properties (color, speed) and methods (drive(), brake())
  - A block object has properties (index, hash, data, prev) and a method (chain())

When you call `first.chain(newData)`, you're using the chain method to create 
a new block object that's linked to the current block.

Concept 4: The Genesis Block - The Beginning
---------------------------------------------
Every blockchain starts with a special block called the "genesis block." It's 
block 0 with hash '0', and it has no previous block (or its previous block is 
itself). This is the starting point for your entire chain.

Think of it like the first page in a history bookâ€”everything else builds upon 
it. If someone tries to rewrite the genesis block, every other block's hash 
becomes invalid!

Concept 5: Recursion and Chaining Objects
------------------------------------------
When you call .chain(), you're creating a new block object that contains a 
reference to the old block as its `.prev` property. This creates a chain where 
you can traverse backwards: block5.prev â†’ block4 â†’ block3 â†’ block2 â†’ block1 â†’ 
genesis block.

Each block "remembers" the block that came before it, forming an unbreakable 
chain.

================================================================================
PART 3: STEP-BY-STEP ALGORITHM (Your Thinking Process)
================================================================================

Step 1: Define the blockChain Function
      - Create a function that takes `data` and `prev` as parameters
      - If `prev` is not provided, use the genesis block: { index: 0, hash: '0' }

Step 2: Calculate the Index
      - The index of the new block is the previous block's index + 1
      - First block: prev.index (0) + 1 = 1
      - Second block: 1 + 1 = 2
      - And so on...

Step 3: Create the Hash
      - Combine: previousBlock.index + previousBlock.hash + JSON.stringify(data)
      - Wait... that's not quite right. Read the examples again!
      - Actually combine: newIndex + previousHash + JSON.stringify(data)
      - Example: '1' + '0' + '{"a":1}' = '10{"a":1}'
      - Pass this combined string to hashCode()

Step 4: Create the Block Object
      - Create an object with properties:
        * index: the calculated index
        * hash: the calculated hash from step 3
        * data: the data passed as argument
        * prev: the previous block object
        * chain: a function that creates the next block

Step 5: Implement the chain() Method
      - This method should accept new data
      - Call blockChain(newData, currentBlock)
      - Return the newly created block
      - This allows you to chain multiple blocks: a.chain(b).chain(c).chain(d)

================================================================================
PART 4: THE COMPLETE SOLUTION WITH COMMENTS
================================================================================

// The hashCode function is providedâ€”don't modify it!
// It creates a unique fingerprint from any string.
const hashCode = str =>
  (
    [...str].reduce((h, c) => (h = (h << 5) - h + c.charCodeAt(0)) & h, 0) >>> 0
  ).toString(36)

// Your blockChain function:
const blockChain = (data, prev = { index: 0, hash: '0' }) => {
  // Step 1: Calculate the index of the new block
  // The new block's index is always 1 more than the previous block's index
  const index = prev.index + 1;
  
  // Step 2: Create the string to hash
  // We need to combine: newIndex + previousHash + stringifiedData
  // Important: Convert data to a string using JSON.stringify()
  const dataString = JSON.stringify(data);
  const hashInput = String(index) + prev.hash + dataString;
  
  // Step 3: Calculate the hash using the provided hashCode function
  const hash = hashCode(hashInput);
  
  // Step 4: Create and return the block object
  // This object has properties for index, hash, data, and prev
  // It also has a chain method that can create the next block
  return {
    index,        // The block's position in the chain (1, 2, 3, ...)
    hash,         // The calculated hash fingerprint
    data,         // The actual data stored in this block
    prev,         // A reference to the previous block
    
    // The chain method: creates the next block in the chain
    chain: (newData) => blockChain(newData, this)
    //      ^^^^^^^^           ^^^^^^^^^^^^^^^^
    //      parameter           calls blockChain with this block as 'prev'
  };
};

Example Usage:
--------------
// Create the first block
const first = blockChain({ a: 1 })
console.log(first.index)     // â†’ 1
console.log(first.data)      // â†’ { a: 1 }
console.log(first.hash)      // â†’ '1103f27'
console.log(first.prev)      // â†’ { index: 0, hash: '0' }

// Create the second block by chaining
const second = first.chain({ hello: 'world' })
console.log(second.index)    // â†’ 2
console.log(second.hash)     // â†’ '18drvvc'
console.log(second.prev)     // â†’ first (the entire first block object)

// Create a chain of multiple blocks
const block5 = first
  .chain({ value: 4455 })
  .chain({ some: 'data' })
  .chain({ cool: 'stuff' })

console.log(block5.index)    // â†’ 5 (we've chained 4 times from index 1)
console.log(block5.hash)     // â†’ '1qr3qfs'

What the outputs mean:
- index: Shows which block this is in the chain (position)
- hash: The unique fingerprint calculated from this block's content
- data: The actual information stored in this block
- prev: The previous block (allows traversing backwards in the chain)

================================================================================
PART 5: UNDERSTANDING THE MATH/LOGIC DEEPER
================================================================================

Let's trace through the first two blocks step-by-step with actual numbers:

FIRST BLOCK:
-----------
Input: blockChain({ a: 1 })
Parameters: data = { a: 1 }, prev = { index: 0, hash: '0' } (default)

Step 1: Calculate index
  index = prev.index + 1 = 0 + 1 = 1

Step 2: Create hash input string
  index = 1
  prev.hash = '0'
  data = { a: 1 }
  JSON.stringify(data) = '{"a":1}'
  
  hashInput = String(1) + '0' + '{"a":1}'
  hashInput = '10{"a":1}'

Step 3: Calculate hash
  hash = hashCode('10{"a":1}')
  hash = '1103f27' âœ“ (matches the example!)

Output: A block object with:
  {
    index: 1,
    hash: '1103f27',
    data: { a: 1 },
    prev: { index: 0, hash: '0' },
    chain: [function]
  }


SECOND BLOCK:
-----------
Input: first.chain({ hello: 'world' })

When .chain() is called, it executes:
  blockChain({ hello: 'world' }, first)

Parameters: data = { hello: 'world' }, prev = first (the entire block from above)

Step 1: Calculate index
  index = prev.index + 1 = 1 + 1 = 2

Step 2: Create hash input string
  index = 2
  prev.hash = '1103f27' (from the first block)
  data = { hello: 'world' }
  JSON.stringify(data) = '{"hello":"world"}'
  
  hashInput = String(2) + '1103f27' + '{"hello":"world"}'
  hashInput = '21103f27{"hello":"world"}'

Step 3: Calculate hash
  hash = hashCode('21103f27{"hello":"world"}')
  hash = '18drvvc' âœ“ (matches the example!)

Output: A block object with:
  {
    index: 2,
    hash: '18drvvc',
    data: { hello: 'world' },
    prev: [the entire first block object],
    chain: [function]
  }


WHY EACH STEP IS NECESSARY:
----------------------------
1. Index increments: So we know the position of each block in the chain
2. Hash calculation: Creates a unique fingerprint that depends on:
   - Index (block position)
   - Previous hash (links to the past)
   - Current data (links to this block's content)
3. Storing prev: Allows traversal and verification of the chain
4. chain() method: Enables intuitive syntax like a.chain(b).chain(c).chain(d)

SECURITY INSIGHT:
If someone tries to change the data in the first block from { a: 1 } to { a: 2 }:
  - The first block's hash would change
  - The second block's hash input would be different (it depends on first's hash)
  - The second block's hash would change
  - The third block's hash would change
  - And so on...
  
This is why blockchain is secureâ€”changing even one character cascades through 
the entire chain, making tampering obvious!

================================================================================
PART 6: KEYWORDS & CONCEPTS TO EXPLORE FURTHER
================================================================================

Want to understand these topics better? Search for:

1. **Hashing and Hash Functions** - The mathematical foundation of blockchain
   Learn about: 
   - How hash functions create unique fingerprints
   - Why hash functions are one-way (you can't reverse them)
   - Popular hash algorithms like SHA-256 (used in Bitcoin)
   - Why even tiny changes create completely different hashes

2. **Blockchain Technology** - The distributed database revolution
   Learn about:
   - How blockchain differs from regular databases
   - Why blockchain is immutable and secure
   - Real-world applications: cryptocurrency, supply chain, healthcare
   - Proof of Work and mining concepts
   - Smart contracts and Ethereum

3. **Cryptography** - The science behind secure communication
   Learn about:
   - Public key cryptography
   - Digital signatures
   - Merkle trees (advanced blockchain structure)
   - Why cryptography is essential for cybersecurity

4. **Data Structures** - How to organize and link data efficiently
   Learn about:
   - Linked lists (similar to blockchain)
   - Trees and graphs
   - Hash tables and how they use hashing
   - Time complexity and efficiency

5. **JSON (JavaScript Object Notation)** - Data format you'll use constantly
   Learn about:
   - How JSON differs from JavaScript objects
   - Parsing and stringifying
   - Why JSON is the standard for web APIs
   - JSON validation and schemas

Websites to explore:
- **Khan Academy** - Free courses on cryptography and computer science fundamentals
- **Blockchain.com** - See real Bitcoin blockchain data and transactions
- **Ethereum.org** - Learn about smart contracts and modern blockchain
- **MDN Web Docs** - JavaScript documentation and tutorials
- **MIT OpenCourseWare** - Free university-level computer science courses

================================================================================
PART 7: TESTING YOUR CODE IN A BROWSER
================================================================================

Method 1: Using the Browser Console (Easiest)
----------------------------------------------
1. Open any website in your browser (Google, Facebook, etc.)
2. Press F12 or Ctrl+Shift+I to open Developer Tools
3. Click on the "Console" tab
4. Paste the entire code block from Part 4 (including the hashCode function)
5. Press Enter

Test Cases to Try:
   Test 1: Create first block
     const first = blockChain({ a: 1 })
     console.log(first.index)  // Should show: 1
     console.log(first.hash)   // Should show: '1103f27'
   
   Test 2: Create second block
     const second = first.chain({ hello: 'world' })
     console.log(second.index)  // Should show: 2
     console.log(second.hash)   // Should show: '18drvvc'
   
   Test 3: Create a long chain
     const longChain = first
       .chain({ value: 4455 })
       .chain({ some: 'data' })
       .chain({ cool: 'stuff' })
     
     console.log(longChain.index)  // Should show: 5
     console.log(longChain.hash)   // Should show: '1qr3qfs'

   Test 4: Create a fork (alternate chain)
     const fork = second
       .chain({ value: 335 })
       .chain({ some: 'data' })
       .chain({ cool: 'stuff' })
     
     console.log(fork.hash)    // Should show: '1x9gsc1' (different from longChain!)
     console.log(fork.index)   // Should show: 5 (same index, different path)

   Test 5: Verify the chain structure
     console.log(second.prev === first)  // Should show: true
     console.log(first.prev)             // Should show: { index: 0, hash: '0' }
     console.log(longChain.prev)         // Shows the previous block in the chain


Method 2: Create an HTML File (More Professional)
---------------------------------------------------
This method is cleaner and shows results on a web page instead of the console.

1. Create a new file named "blockchain-test.html"
2. Copy the HTML code below into that file
3. Open the file in your browser (double-click it or drag it to your browser)
4. You'll see all test results displayed on the page

HTML Test File:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Implementation Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 5px;
        }
        .test-result {
            background-color: white;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result.fail {
            border-left-color: #dc3545;
            background-color: #fff5f5;
        }
        .test-result.pass {
            border-left-color: #28a745;
        }
        .label {
            color: #666;
            font-weight: bold;
        }
        .value {
            color: #007bff;
            font-weight: bold;
        }
        .expected {
            color: #28a745;
            font-weight: bold;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>ðŸ”— Blockchain Implementation Test Suite</h1>
    
    <div id="results"></div>

    <script>
        // The provided hashCode function
        const hashCode = str =>
          (
            [...str].reduce((h, c) => (h = (h << 5) - h + c.charCodeAt(0)) & h, 0) >>> 0
          ).toString(36)

        // Your blockChain function
        const blockChain = (data, prev = { index: 0, hash: '0' }) => {
          const index = prev.index + 1;
          const dataString = JSON.stringify(data);
          const hashInput = String(index) + prev.hash + dataString;
          const hash = hashCode(hashInput);
          
          return {
            index,
            hash,
            data,
            prev,
            chain: (newData) => blockChain(newData, this)
          };
        };

        // Test function to display results
        function test(description, actual, expected) {
            const resultsDiv = document.getElementById('results');
            const pass = JSON.stringify(actual) === JSON.stringify(expected);
            
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${pass ? 'pass' : 'fail'}`;
            
            resultDiv.innerHTML = `
                <p><span class="label">Test:</span> ${description}</p>
                <p><span class="label">Expected:</span> <span class="expected">${JSON.stringify(expected)}</span></p>
                <p><span class="label">Actual:</span> <span class="value">${JSON.stringify(actual)}</span></p>
                <p><span class="label">Status:</span> <span style="color: ${pass ? '#28a745' : '#dc3545'}; font-weight: bold;">${pass ? 'âœ“ PASS' : 'âœ— FAIL'}</span></p>
            `;
            
            resultsDiv.appendChild(resultDiv);
        }

        // Run all tests
        const first = blockChain({ a: 1 });
        
        document.getElementById('results').innerHTML += '<h2>Test 1: First Block Creation</h2>';
        test('first.index should be 1', first.index, 1);
        test('first.data should be { a: 1 }', first.data, { a: 1 });
        test('first.hash should be "1103f27"', first.hash, '1103f27');
        test('first.prev should be genesis block', first.prev, { index: 0, hash: '0' });

        const second = first.chain({ hello: 'world' });
        
        document.getElementById('results').innerHTML += '<h2>Test 2: Second Block (Chaining)</h2>';
        test('second.index should be 2', second.index, 2);
        test('second.data should be { hello: "world" }', second.data, { hello: 'world' });
        test('second.hash should be "18drvvc"', second.hash, '18drvvc');
        test('second.prev should reference first block', second.prev === first, true);

        const longChain = first
          .chain({ value: 4455 })
          .chain({ some: 'data' })
          .chain({ cool: 'stuff' });
        
        document.getElementById('results').innerHTML += '<h2>Test 3: Long Chain</h2>';
        test('longChain.index should be 5', longChain.index, 5);
        test('longChain.hash should be "1qr3qfs"', longChain.hash, '1qr3qfs');

        const fork = second
          .chain({ value: 335 })
          .chain({ some: 'data' })
          .chain({ cool: 'stuff' });
        
        document.getElementById('results').innerHTML += '<h2>Test 4: Forked Chain</h2>';
        test('fork.index should be 5', fork.index, 5);
        test('fork.hash should be "1x9gsc1" (different from longChain)', fork.hash, '1x9gsc1');
        test('Different paths = different hash', longChain.hash === fork.hash, false);

        document.getElementById('results').innerHTML += '<h2>Test 5: Chain Integrity</h2>';
        test('Verify hashCode input for first block', 
             hashCode('10{"a":1}'), 
             '1103f27');
        test('Verify hashCode input for second block', 
             hashCode('21103f27{"hello":"world"}'), 
             '18drvvc');
    </script>
</body>
</html>
```

How to Use the HTML Test File:
1. Create a file named "blockchain-test.html" in any folder
2. Copy the HTML code above and save it
3. Open the file in your browser (Chrome, Firefox, Safari, Edge, etc.)
4. All tests will run automatically and show results on the page
5. Green boxes mean PASS âœ“, red boxes mean FAIL âœ—

================================================================================
PART 8: COMMON MISTAKES TO AVOID
================================================================================

âŒ Mistake 1: Forgetting to use JSON.stringify() on the data
   Problem: Your hash calculation might use [object Object] instead of the actual data
   Solution: Always use JSON.stringify(data) when combining strings for hashing
   Example of wrong way:
     hashInput = index + prev.hash + data  // â† Wrong! data is an object
   Example of right way:
     hashInput = index + prev.hash + JSON.stringify(data)  // âœ“ Correct!

âŒ Mistake 2: Not incrementing the index correctly
   Problem: All blocks have the same index, which is wrong
   Solution: Always calculate new index as prev.index + 1
   Example of wrong way:
     const index = 1  // â† Wrong! Every block would be index 1
   Example of right way:
     const index = prev.index + 1  // âœ“ Correct! Each block increments

âŒ Mistake 3: Using the wrong parameters in chain()
   Problem: The chain method creates blocks, but links are broken
   Solution: Pass `this` as the second argument to blockChain
   Example of wrong way:
     chain: (newData) => blockChain(newData)  // â† Wrong! prev is missing
   Example of right way:
     chain: (newData) => blockChain(newData, this)  // âœ“ Correct!

âŒ Mistake 4: Comparing objects with === (triple equals)
   Problem: You write `block1 === block2` and it always returns false, even 
            when they should be the same
   Solution: Use JSON.stringify() to compare objects, or compare properties
   Example of wrong way:
     if (first.prev === { index: 0, hash: '0' })  // â† Always false!
   Example of right way:
     if (JSON.stringify(first.prev) === JSON.stringify({ index: 0, hash: '0' }))
   Or even better:
     if (first.prev.index === 0 && first.prev.hash === '0')

âŒ Mistake 5: Forgetting to return the block object from blockChain
   Problem: Your function works, but nothing is returned, so const first = 
            blockChain(...) makes first = undefined
   Solution: Make sure your function returns the block object
   Example of wrong way:
     const blockChain = (data, prev) => {
       const index = prev.index + 1;
       // ... calculations ...
       // â† No return statement!
     }
   Example of right way:
     const blockChain = (data, prev) => {
       const index = prev.index + 1;
       // ... calculations ...
       return { index, hash, data, prev, chain }  // âœ“ Returns the block!
     }

================================================================================
PART 9: BONUS CHALLENGES
================================================================================

Once you've finished the basic assignment, try these advanced challenges:

Challenge 1: Validate the Chain
   [Description: Write a function that checks if a block and all its 
    previous blocks are valid. Verify each block's hash by recalculating it. 
    If anyone modified a block, its hash will be different!]
   
   Hint: Create a function like:
     const validateChain = (block) => {
       // Check if this block's hash is correct by recalculating it
       // Then recursively check the previous block
     }

Challenge 2: Display the Full Chain
   [Description: Write a function that traverses backwards from any block 
    through all previous blocks and displays the entire chain like a timeline]
   
   Hint: Create a function like:
     const printChain = (block) => {
       // Start with the current block
       // Keep following .prev until you reach genesis (prev.index === 0)
       // Print or collect all blocks in order
     }

Challenge 3: Find Block by Index
   [Description: Write a function that starts from any block and searches 
    backward to find a block with a specific index number]
   
   Hint: This is like searching through your blockchain history.

Challenge 4: Compare Two Chains
   [Description: Write a function that compares two blocks (possibly from 
    different chains) and tells you if they diverged (different chains) and 
    at which block they diverged]
   
   Hint: This is like detecting a fork in the blockchain!

Challenge 5: Build a String Representation
   [Description: Write a function that returns a nice string representation 
    of a block, showing all its properties in a readable format]
   
   Hint: Try something like:
     const blockToString = (block) => {
       return `Block #${block.index}\nHash: ${block.hash}\nData: ${JSON.stringify(block.data)}...`
     }

================================================================================
PART 10: FINAL THOUGHTS
================================================================================

This assignment teaches several important programming concepts:

1. **Functions and Return Values** - Functions that create and return objects 
   are a core part of JavaScript. Understanding how to structure return values 
   is essential.

2. **Objects and Properties** - You've learned that objects can contain both 
   data (properties) and functions (methods). This is the foundation of 
   object-oriented programming.

3. **Data Structures and Linking** - You've created a linked structure where 
   each block references the previous one. This is used in countless real-world 
   applications beyond blockchain.

4. **Cryptography and Hashing** - Understanding how hashing creates unique 
   fingerprints is fundamental to cybersecurity, blockchain, and modern 
   computing.

5. **Recursive Thinking** - The chain() method calls blockChain(), creating 
   a chain of function calls. Recursion is a powerful technique you'll see 
   everywhere in advanced programming.

These skills are fundamental to all programming. Once you understand these 
concepts, you can build much more complex applications! You're learning the 
same concepts that developers at Google, Facebook, and Microsoft use every day.

Remember: Every expert programmer started exactly where you are right nowâ€”
confused about what a hash is, wondering why objects are so useful. The fact 
that you're pushing through to understand blockchain puts you ahead of most 
people your age!

The future of technology is being built by people who understand these 
fundamentals. Keep learning, keep coding, and keep building cool things. 
You're on an amazing journey! ðŸš€

================================================================================
PART 11: COMPLETE CORRECT SOLUTION
================================================================================

Below is the final, clean version of the solution that you should submit:

```javascript
// The hashCode function is providedâ€”this will be added to your solution
const hashCode = str =>
  (
    [...str].reduce((h, c) => (h = (h << 5) - h + c.charCodeAt(0)) & h, 0) >>> 0
  ).toString(36)

// Your blockChain function implementation
const blockChain = (data, prev = { index: 0, hash: '0' }) => {
  const index = prev.index + 1;
  const hashInput = String(index) + prev.hash + JSON.stringify(data);
  const hash = hashCode(hashInput);
  
  return {
    index,
    hash,
    data,
    prev,
    chain: (newData) => blockChain(newData, this)
  };
};
```

Verification of Correct Output:
--------------------------------
If you run these test cases, you should get these exact outputs:

Test 1: First Block
  const first = blockChain({ a: 1 })
  first.index          â†’ 1
  first.hash           â†’ '1103f27'
  first.data           â†’ { a: 1 }
  first.prev.index     â†’ 0
  first.prev.hash      â†’ '0'

Test 2: Second Block (Using chain)
  const second = first.chain({ hello: 'world' })
  second.index         â†’ 2
  second.hash          â†’ '18drvvc'
  second.data          â†’ { hello: 'world' }
  second.prev === first â†’ true

Test 3: Multiple Chains
  const block5 = first.chain({ value: 4455 }).chain({ some: 'data' }).chain({ cool: 'stuff' })
  block5.index         â†’ 5
  block5.hash          â†’ '1qr3qfs'

Test 4: Different Chains Have Different Hashes
  const fork = second.chain({ value: 335 }).chain({ some: 'data' }).chain({ cool: 'stuff' })
  fork.index           â†’ 5
  fork.hash            â†’ '1x9gsc1'  (DIFFERENT from block5.hash!)

Test 5: Hash Verification
  hashCode('10{"a":1}')                                 â†’ '1103f27'
  hashCode('21103f27{"hello":"world"}')                â†’ '18drvvc'

If your function returns these exact values, you've solved it correctly!

Why This Solution Works:
------------------------
âœ“ Correctly calculates the index by incrementing from the previous block
âœ“ Properly creates the hash input by combining index, prev hash, and stringified data
âœ“ Returns an object with all required properties (index, hash, data, prev)
âœ“ Implements the chain() method that creates new blocks linked to the current block
âœ“ The chain() method uses `this` to reference the current block as prev for the next block
âœ“ Handles the default genesis block when no prev is provided
âœ“ Works with any valid JSON data
âœ“ Creates unique hashes for different data paths (forking)

================================================================================
PART 12: STEP-BY-STEP BROWSER TESTING GUIDE
================================================================================

QUICK START (Easiest Method - 2 minutes):
------------------------------------------

Step 1: Open your browser and go to any website
Step 2: Press F12 to open Developer Tools
Step 3: Click on the "Console" tab
Step 4: Copy and paste the entire code block below and press Enter
Step 5: Run the test cases one by one to see results!

Complete Browser Console Test Script:
-------------------------------------
Copy everything below into your browser console and run it at once:

```javascript
// The provided hashCode function
const hashCode = str =>
  (
    [...str].reduce((h, c) => (h = (h << 5) - h + c.charCodeAt(0)) & h, 0) >>> 0
  ).toString(36)

// Your blockChain function
const blockChain = (data, prev = { index: 0, hash: '0' }) => {
  const index = prev.index + 1;
  const hashInput = String(index) + prev.hash + JSON.stringify(data);
  const hash = hashCode(hashInput);
  
  return {
    index,
    hash,
    data,
    prev,
    chain: (newData) => blockChain(newData, this)
  };
};

// Now run these tests:
console.log('=== TEST 1: First Block ===');
const first = blockChain({ a: 1 });
console.log('first.index:', first.index, '(expected: 1)');
console.log('first.hash:', first.hash, '(expected: "1103f27")');
console.log('first.data:', first.data, '(expected: { a: 1 })');
console.log('first.prev:', first.prev, '(expected: { index: 0, hash: "0" })');

console.log('\n=== TEST 2: Second Block ===');
const second = first.chain({ hello: 'world' });
console.log('second.index:', second.index, '(expected: 2)');
console.log('second.hash:', second.hash, '(expected: "18drvvc")');
console.log('second.data:', second.data, '(expected: { hello: "world" })');
console.log('second.prev === first:', second.prev === first, '(expected: true)');

console.log('\n=== TEST 3: Long Chain ===');
const chain = second
  .chain({ value: 4455 })
  .chain({ some: 'data' })
  .chain({ cool: 'stuff' });

console.log('chain.index:', chain.index, '(expected: 5)');
console.log('chain.hash:', chain.hash, '(expected: "1qr3qfs")');

console.log('\n=== TEST 4: Forked Chain ===');
const fork = second
  .chain({ value: 335 })
  .chain({ some: 'data' })
  .chain({ cool: 'stuff' });

console.log('fork.index:', fork.index, '(expected: 5)');
console.log('fork.hash:', fork.hash, '(expected: "1x9gsc1")');
console.log('Different hashes:', chain.hash !== fork.hash, '(expected: true)');

console.log('\n=== TEST 5: Hash Verification ===');
console.log('hashCode("10{\\"a\\":1}"):', hashCode('10{"a":1}'), '(expected: "1103f27")');
console.log('hashCode("21103f27{\\"hello\\":\\"world\\"}"):', hashCode('21103f27{"hello":"world"}'), '(expected: "18drvvc")');

console.log('\nâœ… All tests completed! Check the results above.');
```

Expected Console Output:
------------------------
```
=== TEST 1: First Block ===
first.index: 1 (expected: 1)
first.hash: 1103f27 (expected: "1103f27")
first.data: {a: 1} (expected: { a: 1 })
first.prev: {index: 0, hash: "0"} (expected: { index: 0, hash: "0" })

=== TEST 2: Second Block ===
second.index: 2 (expected: 2)
second.hash: 18drvvc (expected: "18drvvc")
second.data: {hello: "world"} (expected: { hello: "world" })
second.prev === first: true (expected: true)

=== TEST 3: Long Chain ===
chain.index: 5 (expected: 5)
chain.hash: 1qr3qfs (expected: "1qr3qfs")

=== TEST 4: Forked Chain ===
fork.index: 5 (expected: 5)
fork.hash: 1x9gsc1 (expected: "1x9gsc1")
Different hashes: true (expected: true)

=== TEST 5: Hash Verification ===
hashCode("10{"a":1}"): 1103f27 (expected: "1103f27")
hashCode("21103f27{"hello":"world"}"): 18drvvc (expected: "18drvvc")

âœ… All tests completed! Check the results above.
```

HTML File Method (More Professional):
--------------------------------------
See Method 2 in PART 7 above for the complete HTML file with automatic testing.

To use it:
1. Copy the HTML code from PART 7 Method 2
2. Create a file named "blockchain-test.html" 
3. Save the HTML code to that file
4. Open it in your browser
5. All tests run automatically with pretty formatting

How to Use the HTML Test File:
1. Open "blockchain-test.html" in your browser
2. You'll see a list of all tests with results
3. Green boxes mean the test passed âœ“
4. Red boxes mean the test failed âœ—
5. If any tests fail, check:
   - Did you use JSON.stringify() for the data?
   - Did you calculate index as prev.index + 1?
   - Did you create the hashInput correctly?
   - Did you return the block object?

Troubleshooting:
----------------
Problem: "ReferenceError: hashCode is not defined"
Solution: Make sure you copied the hashCode function into the console/file. 
          It must be defined before blockChain is called.

Problem: "first.hash" shows something like "abc1234" instead of "1103f27"
Solution: Check your hash input string. Make sure you're using:
          index + prev.hash + JSON.stringify(data)
          (not in any other order, and stringify must be used!)

Problem: "second.hash" doesn't match the expected value
Solution: Make sure second.prev is actually the first block. In chain(), 
          use blockChain(newData, this) to pass the current block as prev.

Problem: I see "undefined" for some values
Solution: Your blockChain function might not be returning the block object.
          Make sure you have: return { index, hash, data, prev, chain }

Problem: The chain works but hashes don't match examples
Solution: Don't forget to convert the index to a string!
          Use: String(index) + prev.hash + JSON.stringify(data)

================================================================================
```

This comprehensive implementation guide provides a complete learning resource for understanding and implementing blockchain technology in JavaScript. Good luck, and enjoy building! ðŸš€

================================================================================
